<!DOCTYPE html>
<html>
<head>
	<title>Match3 analyzer</title>
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.1.0/angular-material.min.css">

	<style>
		.playfield {
			padding: 1em;
			width: calc(32px * 9);
		}

		.cell {
			float: left;

			width: 30px;
			height: 30px;

			border: 1px solid white;
			background: #eee;

			outline: none !important;
		}

		.cell--picked {
			animation: disappear .4s;
		}

		.cell--blocker {
			border-color: black;
			border-radius: 10px;
		}

		@keyframes disappear {
			100% { opacity: 0; }
		}
	</style>
</head>


<body ng-app="Match3" ng-cloak layout='column' ng-controller='PlayfieldController'>

	<div flex='33'></div>

	<div layout='row' flex>
		<div flex='33'></div>

		<div class='playfield'>
			<div class='cell' ng-repeat='cell in cells'
				ng-style='{ background: cell.content.color }'
				ng-click='onCellClicked(cell)'
				ng-class='{"cell--picked" : cell.collected, "cell--blocker" : cell.blocker }'>
			</div>
		</div>

		<div layout='column' >
			<h2>Collected</h2>
			<div ng-repeat='(color, count) in collected'><b>{{:: color}}</b>: {{ count }}</div>
		</div>
	</div>
</body>


	<!-- Angular Material requires Angular.js Libraries -->
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-animate.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-aria.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-messages.min.js"></script>

	<!-- Angular Material Library -->
	<script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.1.0/angular-material.min.js"></script>

	<!-- Your application bootstrap  -->
	<script type="text/javascript">
		const PLAYFIELD_SIZE_CELLS = 9;

		/**
		 * You must include the dependency on 'ngMaterial'
		 */
		window.ngApp = angular.module('Match3', ['ngMaterial']);


		window.ngApp.controller('PlayfieldController', ['$scope', function($scope) {

			const colors = [ 'purple', 'red', 'blue', 'green', 'orange' ];

			const cellTypes = [
				{
					// std
					cellsCount: 2,
					actions: {
						action: x => stdAction(x),
						ctor: () => null
					}
				},
				{
					cellsCount: 3,
					actions: {
						action: x => collectLine(x),
						ctor: () => ({ color: 'black' })
					}
				}
			];

			const defaultActions = cellTypes[0].actions;
			const getCellActions = x => cellTypes.filter(bonusType => x >= bonusType.cellsCount).pop().actions

			const cellAt = (col, row) => {
				if (col >= PLAYFIELD_SIZE_CELLS || col < 0) {
					return null;
				}

				return $scope.cells[row * PLAYFIELD_SIZE_CELLS + col];
			};

			const randomCell = () => ({
				color: colors[Math.floor(Math.random() * colors.length)]
			});

			const cellsMatch = (cellA, cellB) => cellA.content.color == cellB.content.color;

			$scope.collected = {};

			$scope.cells = [...new Array(PLAYFIELD_SIZE_CELLS * PLAYFIELD_SIZE_CELLS)].map((x, index) => ({
				content: null,
				col: index % PLAYFIELD_SIZE_CELLS,
				row: Math.floor(index / PLAYFIELD_SIZE_CELLS),
				actions: defaultActions
			}));


			const slideColDown = colIndex => {
				let anythingMoved = false;

				for (let rowIndex = PLAYFIELD_SIZE_CELLS - 1; rowIndex >= 0; --rowIndex) {
					const cell = cellAt(colIndex, rowIndex);
					const cellAbove = cellAt(colIndex, rowIndex - 1);

					if (!cellAbove) {
						if (!cell.content) {
							cell.content = randomCell();
							cell.actions = defaultActions;
							anythingMoved = true;
						}
					}
					else if (!cell.content && cellAbove.content && !cellAbove.blocker) {
						cell.content = cellAbove.content;
						cellAbove.content = null;

						cell.actions = cellAbove.actions;
						cellAbove.actions = null;

						anythingMoved = true;
					}
				}

				return anythingMoved;
			};


			const slideFieldDown = () => {
				for (let colIndex = 0; colIndex < PLAYFIELD_SIZE_CELLS; ++colIndex) {
					while (slideColDown(colIndex)) {
						;	//	yea, do nothing
					}
				}
			};

			const stdAction = (cell) => {
				let result = collectAdjacentCellsOfSameColor(cell);
				cell.actions = getCellActions(result.length);
				return result;
			}

			const collectAdjacentCellsOfSameColor = (initialCell, cellsCollected) => {
				cellsCollected = cellsCollected || [ initialCell ];

				const neighbors = [
					cellAt(initialCell.col - 1, initialCell.row),
					cellAt(initialCell.col + 1, initialCell.row),
					cellAt(initialCell.col, initialCell.row + 1),
					cellAt(initialCell.col, initialCell.row - 1)
				];

				neighbors.forEach(neigborCell => {
					if (neigborCell && neigborCell.content && cellsMatch(initialCell, neigborCell) && cellsCollected.indexOf(neigborCell) < 0) {
						cellsCollected.push(neigborCell);
						collectAdjacentCellsOfSameColor(neigborCell, cellsCollected);
					}
				});

				return cellsCollected;
			};

			const collectLine = (cell) =>
			{
				var direction = Math.random()>.5;
				cell.actions = defaultActions
				return $scope.cells.filter(x=>(direction && x.row == cell.row) || (!direction && x.col == cell.col) )
			}


			const wipeNeighbors = initialCell => {
				const cells = initialCell.actions.action(initialCell);

				if (cells.length < 2) {
					return;
				}

				cells.forEach(cell => { cell.collected = true; });

				$scope.clicksBlocked = true;

				setTimeout(() => {
					cells.forEach(cell => {
						cell.collected = false;

						if (!$scope.collected[cell.content.color]) {
							$scope.collected[cell.content.color] = 0;
						}

						$scope.collected[cell.content.color] += 1;
						cell.content = cell.actions.ctor();
						cell.blocker = false;
					});

					slideFieldDown();
					$scope.clicksBlocked = false;
					$scope.$digest();
				}, 400);
			};


			slideFieldDown();
			
			$scope.cells.forEach(x => { x.blocker = Math.random() > 0.7; } );

			$scope.slideDown = slideFieldDown;

			$scope.onCellClicked = cell => {
				if ($scope.clicksBlocked) {
					return;
				}

				wipeNeighbors(cell);
			};

		}]);
	</script>


</html>
