<!DOCTYPE html>
<html>
<head>
	<title>Match3 analyzer</title>
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.1.0/angular-material.min.css">

	<style>
		.playfield {
			padding: 1em;
			width: calc(32px * 9);
		}

		.cell {
			cursor: pointer;
			font-size: 25px;

			text-align: center;
			float: left;

			width: 30px;
			height: 30px;

			border: 1px solid white;
			background: #eee;

			outline: none !important;
		}

		.cell.cell--empty {
			cursor: default;
		}

		.cell.cell--picked {
			animation: disappear .4s;
		}

		.cell.cell-type--bonus-bomb,
		.cell.cell-type--bonus-horz-arrow {
			background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABZJREFUeNpi2r9//38gYGAEESAAEGAAasgJOgzOKCoAAAAASUVORK5CYII=) !important;
		}

		.cell.cell-type--blocker {
			border-color: black;
			border-radius: 10px;
		}

		@keyframes disappear {
			100% { opacity: 0; }
		}
	</style>
</head>


<body ng-app="Match3" ng-cloak layout='column' ng-controller='PlayfieldController'>

	<div flex='33'></div>

	<div layout='row' flex>
		<div flex='33'></div>

		<div class='playfield'>
			<div class='cell cell-type--{{ cell.content.type }}' ng-repeat='cell in cells'
				ng-style='{ background: cell.content.color }'
				ng-click='cell.content.onClicked(cell)'
				ng-class='{"cell--picked" : cell.isFadingOut, "cell--empty": !cell.content}'>
				{{ cell.content.character }}
			</div>
		</div>

		<div layout='column' >
			<h2>Collected</h2>
			<div ng-repeat='(color, count) in cellsCollectedByColor'><b>{{:: color}}</b>: {{ count }}</div>
		</div>
	</div>
</body>


	<!-- Angular Material requires Angular.js Libraries -->
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-animate.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-aria.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-messages.min.js"></script>

	<!-- Angular Material Library -->
	<script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.1.0/angular-material.min.js"></script>

	<!-- Your application bootstrap  -->
	<script type="text/javascript">
		const PLAYFIELD_SIZE_CELLS = 9;

		/**
		 * You must include the dependency on 'ngMaterial'
		 */
		window.ngApp = angular.module('Match3', ['ngMaterial']);


		const ALL_POSSIBLE_COLORS = [ 'purple', 'red', 'blue', 'green', 'orange' ];
		const INVALID_COLOR = 'white';

		const MIN_CELLS_TO_WIPE = 2;



		window.ngApp.controller('PlayfieldController', ['$scope', function($scope) {

			const cellAt = (col, row) => {
				if (col >= PLAYFIELD_SIZE_CELLS || col < 0) {
					return null;
				}

				return $scope.cells[row * PLAYFIELD_SIZE_CELLS + col];
			};


			const cellsMatch = (cellA, cellB) => cellA.content.color == cellB.content.color;

			$scope.cellsCollectedByColor = {};

			$scope.cells = [...new Array(PLAYFIELD_SIZE_CELLS * PLAYFIELD_SIZE_CELLS)].map((x, index) => ({
				content: null,
				col: index % PLAYFIELD_SIZE_CELLS,
				row: Math.floor(index / PLAYFIELD_SIZE_CELLS)
			}));


			const slideColDown = colIndex => {
				let anythingMoved = false;

				for (let rowIndex = PLAYFIELD_SIZE_CELLS - 1; rowIndex >= 0; --rowIndex) {
					const cell = cellAt(colIndex, rowIndex);
					const cellAbove = cellAt(colIndex, rowIndex - 1);

					if (!cellAbove) {
						if (!cell.content) {
							cell.content = CellsFactory.createNewCellFromTopGenerator();
							anythingMoved = true;
						}
					}
					else if (!cell.content && cellAbove.content && cellAbove.content.canFallDown) {
						cell.content = cellAbove.content;
						cellAbove.content = null;
						anythingMoved = true;
					}
				}

				return anythingMoved;
			};


			const slideFieldDown = () => {
				for (let colIndex = 0; colIndex < PLAYFIELD_SIZE_CELLS; ++colIndex) {
					while (slideColDown(colIndex)) {
						;	//	yea, do nothing
					}
				}
			};


			const wipeNeighbors = cellsToWipe => {
				if (cellsToWipe.length < MIN_CELLS_TO_WIPE) {
					return Promise.resolve({
						cellsWiped: 0,
						onPreparationsFinished() {}
					});
				}

				cellsToWipe.forEach(cell => { cell.isFadingOut = true; });

				$scope.clicksBlocked = true;

				return new Promise(resolve => setTimeout(() => {
					cellsToWipe.forEach(cell => {
						cell.isFadingOut = false;

						if (cell.content) {
							if (!$scope.cellsCollectedByColor[cell.content.color]) {
								$scope.cellsCollectedByColor[cell.content.color] = 0;
							}

							$scope.cellsCollectedByColor[cell.content.color] += 1;
						}
						cell.content = null;
					});

					resolve({
						cellsWiped: cellsToWipe.length,
						onPreparationsFinished: () => {
							slideFieldDown();
							$scope.clicksBlocked = false;
							$scope.$digest();
						}
					});

				}, 400));
			};



			const CellsFactory = (function() {

				const BONUSES_FOR_CELLS_DESTROYED = [{
					priority: 0,
					canGetThisBonusForAchievement: cellsDestroyed => cellsDestroyed >= 4,
					create: () => api.createArrowBombCell()
				}, {
					priority: 1,
					canGetThisBonusForAchievement: cellsDestroyed => cellsDestroyed >= 5,
					create: () => api.createRoundBombCell()
				}];




				const collectAllAdjacentCells = initialCell => $scope.cells.filter(cell => Math.abs(cell.row - initialCell.row) + Math.abs(cell.col - initialCell.col) <= 2);


				const collectTheWholeRowOfACell = initialCell => $scope.cells.filter(cell => cell.row == initialCell.row);


				const collectAdjacentCellsOfSameColor = (initialCell, cellsCollected) => {
					cellsCollected = cellsCollected || [ initialCell ];

					const neighbors = [
						cellAt(initialCell.col - 1, initialCell.row),
						cellAt(initialCell.col + 1, initialCell.row),
						cellAt(initialCell.col, initialCell.row + 1),
						cellAt(initialCell.col, initialCell.row - 1)
					];

					neighbors.forEach(neighborCell => {
						if (neighborCell && neighborCell.content && cellsMatch(initialCell, neighborCell) && cellsCollected.indexOf(neighborCell) < 0) {
							cellsCollected.push(neighborCell);
							collectAdjacentCellsOfSameColor(neighborCell, cellsCollected);
						}
					});

					return cellsCollected;
				};


				const api = {
					createNewCellFromTopGenerator() {
						return {
							color: ALL_POSSIBLE_COLORS[Math.floor(Math.random() * ALL_POSSIBLE_COLORS.length)],
							type: 'generic',
							canFallDown: true,

							onClicked(self) {
								if ($scope.clicksBlocked) {
									return;
								}

								const cellsToWipe = collectAdjacentCellsOfSameColor(self);

								wipeNeighbors(cellsToWipe).then(neighborsWipeResult => {
									const bonusesMightBeCreated = BONUSES_FOR_CELLS_DESTROYED.filter(bonuse => bonuse.canGetThisBonusForAchievement(neighborsWipeResult.cellsWiped));
									bonusesMightBeCreated.sort((a, b) => a.priority - b.priority);

									const bonusToCreate = bonusesMightBeCreated.pop();

									if (bonusToCreate) {
										self.content = bonusToCreate.create();
									}

									neighborsWipeResult.onPreparationsFinished();
								});
							}
						};
					},

					createBlockerCell() {
						return {
							color: ALL_POSSIBLE_COLORS[Math.floor(Math.random() * ALL_POSSIBLE_COLORS.length)],
							type: 'blocker',
							canFallDown: false,

							onClicked(self) {
								;	//	yea, do nothing
							}
						};
					},


					createArrowBombCell() {
						return {
							color: INVALID_COLOR,
							type: 'bonus-horz-arrow',
							character: '⇿',
							canFallDown: true,

							onClicked(self) {
								const cellsToWipe = collectTheWholeRowOfACell(self);
								wipeNeighbors(cellsToWipe).then(neighborsWipeResult => {
									neighborsWipeResult.onPreparationsFinished();
								});
							}
						};
					},


					createRoundBombCell() {
						return {
							color: INVALID_COLOR,
							type: 'bonus-bomb',
							character: '☠',
							canFallDown: true,

							onClicked(self) {
								const cellsToWipe = collectAllAdjacentCells(self);
								wipeNeighbors(cellsToWipe).then(neighborsWipeResult => {
									neighborsWipeResult.onPreparationsFinished();
								});
							}
						};
					},
				};


				return api;
			})();



			slideFieldDown();

			$scope.cells.forEach(cell => {
				if (Math.random() > 0.8) {
					cell.content = CellsFactory.createBlockerCell();
				}
			});
		}]);
	</script>


</html>
